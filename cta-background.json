{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.50*2.); uv = rotate(uv, (0.00 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[{"min":992,"name":"Desktop","max":null,"props":{"pos":{"type":"Vec2","_x":0.7697424610063979,"_y":0.5461572565790909},"radius":0.42}},{"name":"Tablet","min":576,"props":{"radius":0.24,"pos":{"type":"Vec2","_x":0.1681415929203539,"_y":0.22313527180783815}},"max":991}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"beam","radius":0.42,"speed":0.25,"trackMouse":0.1,"mouseMomentum":1,"animating":false,"isMask":0,"states":{"appear":[{"type":"appear","id":"16bc630c-4f69-4908-8825-1eadd908ec06","prop":"radius","transition":{"delay":325,"ease":"easeOutExpo","duration":1050},"complete":false,"progress":0,"initialStateSet":false,"value":0,"uniformData":{"type":"1f","name":"uRadius"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uPos; uniform float uRadius;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.01 * TWO_PI) * skew; center = center * rot(0.01 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; return brightness * vec3(0.39215686274509803, 0.39215686274509803, 0.39215686274509803); }vec3 getBeam(vec2 uv) { vec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), 0.10); return drawPoint(uv, pos, uRadius); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"radius":{"name":"uRadius","type":"1f","value":0.5},"pos":{"name":"uPos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}}}}},{"breakpoints":[{"min":992,"max":null,"props":{"radius":0.294,"pos":{"type":"Vec2","_x":0.4497854129868758,"_y":0.36152823026272735},"angle":0.0162},"name":"Desktop"},{"min":576,"max":991,"name":"Tablet","props":{"pos":{"type":"Vec2","_x":0.49999999999999994,"_y":0.4785082174462705},"radius":0.24,"angle":-0.0351}}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"beam","pos":{"type":"Vec2","_x":0.4497854129868758,"_y":0.36152823026272735},"radius":0.294,"speed":0.25,"trackMouse":0.1,"mouseMomentum":1,"animating":false,"isMask":0,"states":{"appear":[{"type":"appear","id":"2c759d8a-d45a-4138-9f0e-8de176d70330","prop":"radius","transition":{"duration":1850,"ease":"easeOutExpo","delay":225},"complete":false,"progress":0,"initialStateSet":false,"value":0,"uniformData":{"type":"1f","name":"uRadius"}},{"type":"appear","id":"54e0f3b3-1fe7-4e3b-a099-ac2cb0e90de8","prop":"pos","transition":{"duration":1925,"delay":450,"ease":"easeInOutQuart"},"complete":false,"progress":0,"initialStateSet":false,"value":{"type":"Vec2","_x":-1,"_y":-1},"uniformData":{"type":"2f","name":"uPos"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uPos; uniform float uRadius; uniform float uAngle;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(uAngle * TWO_PI) * skew; center = center * rot(uAngle * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; return brightness * vec3(0.39215686274509803, 0.39215686274509803, 0.39215686274509803); }vec3 getBeam(vec2 uv) { vec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), 0.10); return drawPoint(uv, pos, uRadius); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"pos":{"name":"uPos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}},"radius":{"name":"uRadius","type":"1f","value":0.5},"angle":{"name":"uAngle","type":"1f","value":0}}}},{"breakpoints":[{"name":"Desktop","min":992,"max":null,"props":{"radius":0.16,"pos":{"type":"Vec2","_x":0.23991419034227984,"_y":0.22577159326540122}}},{"min":576,"props":{"pos":{"type":"Vec2","_x":0.8489254108723135,"_y":0.838811630847029},"radius":0.9},"name":"Tablet","max":991}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"beam","radius":0.16,"speed":0.25,"trackMouse":0.1,"mouseMomentum":1,"animating":false,"isMask":0,"states":{"appear":[{"type":"appear","id":"03ea96cd-43e2-4d92-a319-f508486daa2e","prop":"radius","transition":{"delay":125,"ease":"easeOutExpo","duration":2875},"complete":false,"progress":0,"initialStateSet":false,"value":0,"uniformData":{"type":"1f","name":"uRadius"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uPos; uniform float uRadius;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.01 * TWO_PI) * skew; center = center * rot(0.01 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / dist; return brightness * vec3(0.39215686274509803, 0.39215686274509803, 0.39215686274509803); }vec3 getBeam(vec2 uv) { vec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), 0.10); return drawPoint(uv, pos, uRadius); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 1.00); result += dither;fragColor = vec4(result, bg.a); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"pos":{"name":"uPos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}},"radius":{"name":"uRadius","type":"1f","value":0.5}}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradientMap","speed":0.5,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime; vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059); case 2: return vec3(1, 0.9490196078431372, 0.011764705882352941); case 3: return vec3(1, 0.9450980392156862, 0.7411764705882353); case 4: return vec3(1, 0.9450980392156862, 0.7411764705882353); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0 + 0.02 * a * (1.0 - a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { for (int i = 0; i < 5; i++) { float colorPosition = float(i) / float(5); float nextColorPosition = float(i + 1) / float(5); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(getColor(i)); vec3 linEnd = linear_from_srgb(getColor(i + 1)); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return srgb_from_linear(getColor(5 - 1)); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float position = smoothstep(0., 1., color.r) * (0.44 * 2.); float posOffset = (dot(vec2(0.5, 0.5).x, vec2(0.5, 0.5).y) + 0.20 + 0.0001) * 2.; position -= (uTime*0.01 + posOffset); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? fract(-position) : fract(position); animatedPos = reverse ? animatedPos - 1./float(5) : animatedPos - 1./float(5); animatedPos = clamp(animatedPos, 0. - 1./float(5), 1.0);vec3 gradientColor = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; gradientColor += dither; vec3 mixedColor = mix(color.rgb, gradientColor, 1.00);color.rgb = mixedColor;fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[{"min":992,"max":null,"name":"Desktop","props":{"turbulence":0.5,"noiseType":0,"frequency":0.28200000000000003,"pos":{"type":"Vec2","_x":0.13497857901998192,"_y":0.349310132932968},"angle":0.0081,"direction":0.5}},{"max":991,"name":"Tablet","props":{"direction":0.4,"angle":0.0297,"pos":{"type":"Vec2","_x":0.8555625790139065,"_y":0.8350189633375473},"frequency":1,"noiseType":"0","turbulence":0.26},"min":576}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"noise","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform vec2 uPos; uniform float uTime; uniform float uAngle; uniform float uFrequency; uniform float uTurbulence; uniform float uDirection; uniform int uNoiseType; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec2 get2sNoise(vec2 uv, vec2 textureCoord) { vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(uv * vec2(uDirection, 1. - uDirection) * 0.7, 0.00 + uTime*0.02)); vec2 offset = noise.xy/7. + 0.5; return mix(textureCoord, offset, uTurbulence); }vec2 getPerlinNoise(vec2 uv, vec2 textureCoord) { vec2 skew = vec2(uDirection, 1. - uDirection); float noiseX = perlin_noise(vec3( uv * skew, 0.00 + uTime * 0.03 ));float noiseY = perlin_noise(vec3( (uv + vec2(4.37)) * skew, 0.00 + uTime * 0.03 ));vec2 offset = vec2(noiseX * 1.5, noiseY * 1.5) * 0.5 + 0.5;return mix(textureCoord, offset, uTurbulence * 1.2); }vec3 hash3(vec2 p) { vec3 q = vec3(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9))); return fract(sin(q)*43758.5453); }float voronoise(vec2 uv, vec2 textureCoord) { float u = 1.; float v = 1.; uv *= vec2(uDirection, 1.0 - uDirection); uv *= 2.91;vec2 x = uv; vec2 p = floor(x); vec2 f = fract(x); float k = 1.0 + 63.0 * pow(1.0-v,4.0); float va = 0.0; float wt = 0.0; for( int j=-2; j<=2; j++ ) for( int i=-2; i<=2; i++ ) { vec2 g = vec2( float(i),float(j) ); vec3 o = hash3( p + g ) * vec3(u,u,1.0); o.xy += 0.5 * vec2( sin(uTime * 0.1 + 0.00 + o.x * 6.28), cos(uTime * 0.1 + 0.00 + o.y * 6.28) ); vec2 r = g - f + o.xy; float d = dot(r,r); float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k ); va += o.z*ww; wt += ww; } return va/wt; } vec2 getVoronoiNoise(vec2 uv, vec2 textureCoord) { vec2 offset = vec2(voronoise(uv, textureCoord), voronoise(uv + vec2(9.2, 1.2), textureCoord));return mix(textureCoord, offset, uTurbulence); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { switch(uNoiseType) { case 0: return get2sNoise(uv, textureCoord); break; case 1: return getPerlinNoise(uv, textureCoord); break; case 2: return getVoronoiNoise(uv, textureCoord); break; default: return vec2(0.); } }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = uPos + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = mPos; vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * uFrequency; st = rot(uAngle * -1. * 2.0 * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"direction":{"name":"uDirection","type":"1f","value":0.5},"angle":{"name":"uAngle","type":"1f","value":0},"pos":{"name":"uPos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}},"frequency":{"name":"uFrequency","type":"1f","value":0.2},"noiseType":{"name":"uNoiseType","type":"1i","value":0},"turbulence":{"name":"uTurbulence","type":"1f","value":0.5}}}},{"breakpoints":[{"props":{"pos":{"type":"Vec2","_x":0,"_y":0},"amplitude":0.5,"frequency":0.57,"mouseMomentum":0,"mixRadiusInvert":0,"speed":0.11,"angle":0.0054,"trackMouse":0},"name":"Desktop","max":null,"min":992},{"max":991,"min":576,"name":"Tablet","props":{"frequency":0.56,"amplitude":0.61,"angle":0.0297,"mixRadiusInvert":0,"speed":0.12,"mouseMomentum":0.31,"pos":{"type":"Vec2","_x":0.6981668773704173,"_y":0.6529709228824273},"trackMouse":0.06}}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"fbm","speed":0.11,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform float uAmplitude; uniform float uFrequency; uniform vec2 uPos; uniform int uMixRadiusInvert; uniform float uAngle;uniform sampler2D uMaskTexture; uniform float uTrackMouse; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }const int OCTAVES = 6; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }mat2 rotHalf = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));float fbm (in vec3 st) { float value = 0.0; float amp = .25; float frequency = 0.; float aM = (0.1 + uAmplitude * .65); vec2 shift = vec2(100.0); for (int i = 0; i < OCTAVES; i++) { value += amp * perlin_noise(st); st.xy *= rotHalf * 2.5; st.xy += shift; amp *= aM; } return value; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; float multiplier = 6.0 * (uFrequency / ((aspectRatio + 1.) / 2.));vec2 mPos = uPos + mix(vec2(0), (uMousePos-0.5), uTrackMouse); vec2 pos = mPos; float mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00))); if(uMixRadiusInvert == 1) { mDist = max(0., (0.5 - mDist)); }vec2 st = (uv * vec2(aspectRatio, 1) + (1. - pos) - vec2(1)) * multiplier * aspectRatio; st = rot(uAngle * -1. * 2.0 * PI) * st; vec2 drift = vec2(uTime * 0.005);float time = uTime * 0.025;vec2 r = vec2( fbm(vec3(st - drift + vec2(1.7, 9.2), 0.00*25. + time)), fbm(vec3(st - drift + vec2(8.2, 1.3), 0.00*25. + time)) );float f = fbm(vec3(st + r - drift, 0.00*25. + time)) * 0.33;vec2 offset = (f * 2. + (r * 0.33));vec4 color = texture(uTexture, uv + offset * mDist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"frequency":{"name":"uFrequency","type":"1f","value":0.2},"amplitude":{"name":"uAmplitude","type":"1f","value":0.5},"angle":{"name":"uAngle","type":"1f","value":0},"mixRadiusInvert":{"name":"uMixRadiusInvert","type":"1i","value":0},"pos":{"name":"uPos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}},"trackMouse":{"name":"uTrackMouse","type":"1f","value":0}}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"dither","speed":0.5,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;const int MAX_LEVEL = 4;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float getRandNoise(vec2 st, vec2 offset) { return fract(sin(dot(st + offset, vec2(12.9898, 78.233))) * 43758.5453) + 0.001; }vec3 dither(vec3 color, vec2 st) { float delta = floor(uTime); vec2 offset = vec2(random(vec2(123,16) + delta), random(vec2(56,96) + delta)); float noise = 0.0; noise = getRandNoise(st, offset); color += (noise - 0.505) * 0.56; return round(color * (1.0 / 0.56)) * 0.56; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float delta = floor(uTime); vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }color.rgb = mix(color.rgb, dither(color.rgb, uv), 0.32); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}}],"options":{"name":"\"Raycast\" bg","fps":60,"dpi":1.5,"scale":1,"includeLogo":true,"isProduction":false},"version":"1.3.2","id":"y8yO1ikuA0qhiwvQr0MG"}
